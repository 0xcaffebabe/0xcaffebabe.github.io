---
layout: post
title:  "使用AOP实现参数验证"
date:   2018-10-29T12:50:05
category: JAVA
tags: [JAVA]
---

使用AOP实现参数验证

<p>今天，我们使用AOP来开发一个参数验证。</p><p>首先，我们理理这个参数验证的原理以及流程。</p><p><span style="font-size: x-large;">第一步</span>，我们会定义一个注解，这个注解可以被用来修饰某一方法的参数，如下:</p><pre><code>public Object login(@RequestBody @CustomValid LoginDto loginDto, HttpSession session){<br>        return loginService.login(loginDto,session);<br>    }</code></pre><p>这里的@CustomValid就是我们的自定义注解。</p><p>&nbsp;它的代码如下：</p><pre><code>@Retention(RetentionPolicy.RUNTIME)<br>@Target(ElementType.PARAMETER)<br>public @interface CustomValid {<br>}</code></pre><p><span style="font-size: x-large;">第二步</span>，我们会在切入点的环绕通知中获取所有的方法参数:</p><pre><code>//获取所有的方法参数<br>        Signature signature = joinPoint.getSignature();<br>        MethodSignature methodSignature = (MethodSignature)signature;<br>        Method targetMethod = methodSignature.getMethod();<br><br>        Parameter[] parameters=targetMethod.getParameters();</code></pre><p>通过这一句代码来获取需要验证的方法参数类型：</p><pre><code>List&lt;Class&gt; list=validationProcessor.getValidateClass(parameters);</code></pre><p>其内部实现:</p><pre><code>public List&lt;Class&gt; getValidateClass(Parameter[] parameters){<br><br>        List&lt;Class&gt; list=new ArrayList&lt;Class&gt;();<br><br>        for (Parameter parameter : parameters) {<br>            Annotation[] annotations=parameter.getAnnotations();<br>            for (Annotation annotation : annotations) {<br>                if(annotation instanceof CustomValid){<br>                    list.add(parameter.getType());<br>                }<br>            }<br>        }<br>        return list;<br>    }</code></pre><p>原理就是通过反射获取参数数组中各个参数上的注解，并判断是否有@CustomValid这个注解，如果有就加入列表，最终返回。</p><p><span style="font-size: x-large;">第三步</span>，获取到需要验证的参数类型之后，我们进行双重循环，找出需要进行参数验证的参数对象：</p><pre><code>for (Object arg : joinPoint.getArgs()) {<br>            for (Class aClass : list) {<br>                //将参数与需要验证的参数类型进行匹配<br>                if(arg.getClass().getName().equals(aClass.getName())){<br>                    try {<br>                        //如果验证失败<br>                        ValidResult validResult=validationProcessor.valid(arg.getClass().getDeclaredFields(),arg);<br>                        if(!validResult.isValid()){<br>                            return new Result&lt;String&gt;(ResultState.ERROR,validResult.getValidFailMessage());<br>                        }<br>                    } catch (IllegalAccessException e) {<br>                        e.printStackTrace();<br>                    }<br>                }<br>            }<br>        }</code></pre><p>这里validationProcessor有一个valid方法，该方法通过参数对象的所有成员变量，并取出每个成员变量上的注解，进一步进行验证，代码如下：</p><pre><code>public ValidResult valid(Field[] fields, Object target) throws IllegalAccessException {<br><br>        for (Field field : fields) {<br>            //获取每个成员的注解<br>            Annotation[] annotations=field.getDeclaredAnnotations();<br><br>//            判断注解是否在validMapping里面<br>            for (Annotation annotation : annotations) {<br>                ValidInterface validInterface=validMapping.get(annotation.annotationType());<br>                //如果validMapping拥有相关实现<br>                if(validInterface!=null){<br>                    field.setAccessible(true);<br>                    //如果这个成员变量注解验证失败<br>                    if(! validInterface.valid(field.get(target))){<br>                        return new ValidResult(false,validInterface.getErrorMessage(field.getName()));<br>                    }<br>                }<br>            }<br><br>        }<br><br>        return new ValidResult(true);<br>    }</code></pre><p>这里面有一个validMapping对象，该map维护验证注解与内部验证类的映射关系：</p><pre><code>private HashMap&lt;Class&lt;? extends Annotation&gt;,ValidInterface&gt; validMapping=new HashMap&lt;&gt;();<br><br>    {<br>        //注册验证注解实现<br>        validMapping.put(CustomNotNull.class, new CustomNotNull.Validation());<br>        validMapping.put(CustomEmail.class,new CustomEmail.validation());<br>    }</code></pre><p>其中，每一个验证注解都会实现一个ValidInterface接口，代码如下:</p><pre><code>public interface ValidInterface {<br><br>     boolean valid(Object object);<br><br>     String getErrorMessage(String fieldName);<br>}</code></pre><p>当验证器进行验证的话，valid方法会被调用，如果验证通过，返回true 反之false。</p><p>getErrorMessage 则是返回验证失败后的提示信息。&nbsp;<br></p><p>这是ValidResult的代码：</p><pre><code>public class ValidResult {<br><br>    private boolean isValid;<br><br>    private String validFailMessage;<br><br>    public ValidResult(boolean isValid,String validFailMessage){<br>        this.isValid=isValid;<br>        this.validFailMessage=validFailMessage;<br>    }<br><br>    public ValidResult(boolean isValid){<br>        this.isValid=isValid;<br>    }<br>}</code></pre><p>其主要职责就是存放验证结果。</p><p>这样，一个完整的参数验证流程就完成了，让我们来总结一下：</p><p>1.循环判断参数是否含有@CustomValid注解，若有则进行下一步，否则退出。</p><p>2.取出含有@CustomValid注解的参数对象，取出其所有的成员变量。</p><p>3.循环获得每个成员变量上的注解，若在验证处理器内部拥有注册，则调用这个验证注解提供的验证接口。</p><p>4.返回验证结果，让切入点的环绕通知决定下一步结果。</p><p><br></p><p>不完美的地方：</p><p>在这里，我们通过手工的方式进行了验证接口的注册：</p><pre><code>private HashMap&lt;Class&lt;? extends Annotation&gt;,ValidInterface&gt; validMapping=new HashMap&lt;&gt;();<br><br>    {<br>        //注册验证注解实现<br>        validMapping.put(CustomNotNull.class, new CustomNotNull.Validation());<br>        validMapping.put(CustomEmail.class,new CustomEmail.validation());<br>    }</code></pre><p>这个做法在我看来，是不够完美的，我想是否可以运用多态或者继承，来实现验证注解与验证处理接口的联系？而非这样进行手工注册。</p><p>这里是一个需要思考的地方。</p>