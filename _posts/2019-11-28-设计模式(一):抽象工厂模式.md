---
layout: post
title:  "设计模式(一):抽象工厂模式"
date:   2019-11-28T012:00:00
category: 设计模式
tags: [设计模式]
---


提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体类

# 抽象工厂模式

设现在有一个需求，我们系统当中需要两种产品：ProductA,ProductB,这两种产品都是抽象类型，也就说，它们只是一个接口，产品的具体功能由子类或者实现类提供

```java
interface ProductA{}

interface ProductB{}
```

## 抽象工厂

我们需要一个工厂，来生产这些产品，同样，也是一个抽象类，具体实现交由子类实现

```java
abstract class AbstractFactory{

    public abstract ProductA createProductA();

    public abstract ProductA createProductB();
}
```

##　具体工厂

接下来，我们要实现这样一个抽象工厂，做出一个具体工厂

```java
class ConcreteFactoryA extends AbstractFactory{

    @Override
    public ProductA createProductA() {
        // 生成产品Ａ
    }

    @Override
    public ProductB createProductB() {
        // 生成产品Ｂ
    }
}
```

这样子，我们就可以根据实际需要，不断扩充具体工厂的类型，从而不用修改之前的代码，也能生产新产品

## 使用

客户在使用的时候，他获取的是`AbstractFactory`工厂类型，对于他来说，具体是哪个工厂提供的哪个具体产品，都是透明的，这样就实现了客户与具体实现之间的解耦

```java
AbstractFactory factory = new ConcreteFactoryA();
factory.createProductA();
```

## 类图

![](https://upload.wikimedia.org/wikipedia/commons/9/9d/Abstract_factory_UML.svg)

## 实例

现在，假设我们有一个饮料工厂，该饮料工厂可以生成茶与咖啡

```java
interface Tea{}

interface Coffee {}

abstract class DrinkFactory{

    public abstract Coffee createCoffee();

    public abstract Tea createTea();
}
```

我们创建一个北京工厂，该工厂供应铁观音与速溶咖啡

```java
class BeijingFactory extends DrinkFactory{

    @Override
    public Coffee createCoffee() {
        class InstantCoffee implements Coffee{};
        return new InstantCoffee();
    }

    @Override
    public Tea createTea() {
        class TieGuanYin implements Tea{}; 
        return new TieGuanYin();
    }
}
```

同样也可以创建一个南京工厂，供应红茶和摩卡咖啡

```java
class NanJinFactory extends DrinkFactory{

    @Override
    public Coffee createCoffee() {
        class Mocha implements Coffee{};
        return new Mocha();
    }

    @Override
    public Tea createTea() {
        class RedTea implements Tea{};
        return new RedTea();
    }
}
```

对于客户来说，它可以在两个不同的工厂之间选择，并且无需关心具体的工厂类型

```java
DrinkFactory factory = new BeijingFactory();
factory.createCoffee();
```

## 总结

### 优点与缺点

- 分离了具体的累。客户与类的实现相分离
- 产品系列易于交换。
- 有利于产品的一致性保持
- **难以支持新产品**，一旦要增加新产品，那就意味着要更改抽象工厂接口，一旦需要更改接口，那许多类就要跟着改变了

### 什么时候用

- 一个系统需要独立于它的产品对象、组合、表示
- 一个系统需要多个产品系列
- 强调一系列相关的产品对象的设计以便联合使用
- 提供一个产品类库，但只提供它们的接口



