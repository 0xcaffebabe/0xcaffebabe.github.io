---
layout: post
title:  "设计模式(二):生成器模式"
date:   2019-12-2T012:00:00
category: 设计模式
tags: [设计模式]
---

将复杂对象的构建与表示相分离，同样的构建过程可以创建不同的表示

# 生成器模式

现在的系统有如下需求，提供一种功能复杂的对象，构造它可能需要很多步骤，也很复杂，我们需要分离它的表示与构建过程。

```java
class Product{
    // 复杂的构建
}
```

## 生成器

同时，我们需要一个生成器抽象类，定义对象的构建过程

```java
abstract class AbstractProductBuilder{
    protected Product product;

    abstract AbstractProductBuilder part1();
    abstract AbstractProductBuilder part2();

    Product build(){
        return product;
    }
}
```

我们只需要继承这个抽象类，实现具体生成器即可

```java
class ConcreteProductBuilder extends AbstractProductBuilder{

    @Override
    AbstractProductBuilder part1() {
        product = new Product();
        // 对product做一些操作
        return this;
    }

    @Override
    AbstractProductBuilder part2() {
        // 对product做一些操作
        return this;
    }
}
```

## 指挥者

同时，我们还需要一个指挥者对象，它隔离了客户与创建的过程，同时该负责调用构造器的各个调用过程

```java
class Director{

    AbstractProductBuilder builder;

    public Director(AbstractProductBuilder builder) {
        this.builder = builder;
    }

    public Product construct(){
        builder.part1();
        builder.part2();
        return builder.build();
    }
}
```

## 使用

```java
Director director = new Director(new ConcreteProductBuilder());
director.construct();
```

## 类图

![](https://www.cnblogs.com/images/cnblogs_com/mhx1982/builder.GIF)

## 何时使用

- 创建复杂对象的算法要独立于对象的组成
- 同样的构造过程可以使对象有不同的表现形式

## 效果

- 生成器可以隐藏产品的表示和内部结构
- 构造代码与表示代码分离
- 可以对构造过程进行更精细的控制

## 实例

ProcessBuilder是java.lang提供的一个方便Process构造的类，我们可以直接通过一个生成器构造Proces，不仅能方便命令的构建，而且可以直接重定向错误流

```java
Process pb = new ProcessBuilder()
                .command("ping","baidu.com")
                .redirectErrorStream(true)
                .start();
```

