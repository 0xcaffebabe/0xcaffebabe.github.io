---
layout: post
title:  "设计模式(五):单例模式"
date:   2019-12-23T010:00:00
category: 设计模式
tags: [设计模式]
---

一个类仅有一个实例，并拥有一个全局访问点

# 单例模式

有时候，创建一个类的一个实例代价是很大的，所以在我们的系统当中，对于某个类，我们只想创建一个实例，那么在这时候，对象就不能开放它的创建接口，交由程序员创建了，创建对象的接口或者也叫构造器应该是私有的。

那么，既然构造器是私有的，那还怎么创建对象？

很简单，只需要把创建对象的代码转移到类里面就好了。

## 单例类

设我们的系统有这样的一个单例类

```java
class Singleton{ }
```

## 私有的构造器

只允许它在系统存在一份实例,所以我们必须隐藏它的构造器

```java
private Singleton(){}
```

创建实例的责任交给这个类

```java
private static final Singleton INSTANCE = new Singleton();
```

由于这段代码是在类里面，所有权限修饰符对它不起作用

## 全局访问点

接着，我们只需要添加一个静态方法，以便能让外界通过这个方法获取到它的实例

```java
public static Singleton getInstance(){
        return INSTANCE
}
```

## 客户使用

对于客户来说，他只需要通过`Singleton.getInstance()`访问即可。

## 其他问题

### 延时初始化

有时候，我们不想在系统一运行就加载实例，而是什么时候需要，什么时候再创建，那么我们可以采用延时初始化的方式

```java
class Singleton{

    private static Singleton INSTANCE ;

    private Singleton(){}

    public static Singleton getInstance(){
        if (INSTANCE == null) {
            INSTANCE = new Singleton();
        }
        return INSTANCE
    }
}
```

但是这段代码有线程安全问题，当在并发的环境下可能会创建多个实例,于是我们需要对它进行同步

```java
public static synchronized Singleton getInstance(){...}
```

但这个同步代码太大，每次获取实例都会加锁，我们换一个思路

```java
if (INSTANCE == null) {
            synchronized (Singleton.class){
                if (INSTANCE == null){
                    INSTANCE = new Singleton();
                }
            }

}
```

这样就不会造成不必要的同步

## 优点

- 对唯一实例受控访问
- 操作与表示更简单
- 实例数目可变

##　类图

![](https://www.runoob.com/wp-content/uploads/2014/08/singleton_pattern_uml_diagram.jpg)

## 实例

在JDK中，RunTime的设计就是采用的单例模式

```java
public class Runtime {
    private static final Runtime currentRuntime = new Runtime();
    ...
    public static Runtime getRuntime() {
        return currentRuntime;
    }
}
```