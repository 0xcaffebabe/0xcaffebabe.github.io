---
layout: post
title:  "设计模式(七):桥接模式"
date:   2019-12-24T012:00:00
category: 设计模式
tags: [设计模式]
---

将抽象部分与实现部分相分离，以便它们能独立地演化

# 桥接模式

一个接口可以有多个实现类，在进行编程时，可以针对接口进行变成而非具体实现。
但是随着系统的演化，接口的实现类可能会越来越多，这样就会导致接口与实现耦合过紧，想要独立修改接口或具体实现，会变得很难。

## 抽象接口

这个接口就是我们系统刚开始时所定义的接口

```java
interface Abstraction{
    void run();
}
```

## 实现接口

```java
class Implementor1 implements Abstraction{
    @Override
    public void run() { }
}
class Implementor2 implements Abstraction{
    @Override
    public void run() { }
}
// ...
```

## 问题

随着实现类不断增加，我们可能发现implementorx与implementory可以抽象出一个共同接口，而且我们不想让implementor与Abstraction接口关系太过紧密，想要解除耦合，我们可以引入一个中间件

```java
interface Implementor extends Abstraction{
    
    @Override
    void run();
    
    void run1();
}
```

这样就降低了xy与顶层接口的耦合，并且提高了代码的复用率

## 类图

至此，我们画出类图

![](https://www.cnblogs.com/images/cnblogs_com/houleixx/jiegou.JPG)

## 效果

- 分离接口与具体实现
- 提高了灵活性
- 对客户透明

## 实例

考虑一个跨平台窗体程序，我们有一个Window接口

```java
interface Window{
    void paint();
}
```

我们可以直接实现它

```java
class IconWindow implements Window{

    @Override
    public void paint() {}
}
```

但是可能在不同的系统下，都有不同的实现，于是我们再定义一个实现接口

```java
interface WindowImplementor extends Window{
    void paint1();
}
```

这个接口就可以导出具体平台的窗体实现类

```java
class WindowsWindow implements WindowImplementor{
    // ..
}
class LinuxWindow implements WindowImplementor{
    // ..
}
```

