---
layout: post
title:  "设计模式(九):装饰模式"
date:   2019-12-27T016:00:00
category: 设计模式
tags: [设计模式]
---

给一个对象添加额外的职责

# 装饰器模式

在我们的系统当中，有时候需要把一个对象装饰成另外一个对象，但是这个被装饰后的对象仍然提供先前它所提供的功能（接口），这样的模式我们称之为装饰模式

## 被装饰者

```java
class Subject{
    void run(){
        System.out.println("subject run");
    }
}
```

## 共同的接口

由于装饰器与被装饰者都拥有相同的接口，所以我们可以直接继承被装饰类，生成一个装饰类

```java
class SubjectDecorator extends Subject{
    // 添加的额外职能
    void superRun(){
        super.run();
        System.out.println("run append");
    }
}
```

这样就可以通过装饰器模式给一个对象添加额外的职能

## 使用

对于客户来说，这个对象是不是是装饰者是透明的，也就说说客户不必知道他目前使用的Subject是真的Subject还是SubjectDecorator

```java
Subject subject = new SubjectDecorator();
```

## 何时使用

## 类图

![](https://images0.cnblogs.com/blog/296990/201301/26160050-91ebe03edf184c2da06e52074451c0da.x-png)

## 实例

在JAVA中，最熟悉的使用装饰器模式的设计就是IO流，所有的输入输出流都继承InputStream与OutputStream

```java
BufferedInputStream is = new BufferedInputStream(new FileInputStream("file"));
```

