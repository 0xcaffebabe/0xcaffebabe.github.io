---
layout: post
title:  "设计模式(十二):代理模式"
date:   2019-12-30T021:00:00
category: 设计模式
tags: [设计模式]
---

为其他对象提供一个代理访问控制

# 代理模式

谈起代理模式，做JAVA开发的肯定会熟悉，在JAVA开发中，有一种编程方法叫做动态代理，它会根据现有的类生成一个代理类，这个代理类，和原来的类提供相同的接口，但是能对原来的接口调用进行控制

## 被代理对象

```java
class Subject{}
```

## 代理对象

因为代理对象须提供被代理对象同样的接口，所以在这里代理类可以直接继承被代理类

```java
class Proxy extends Subject{
    private Subject subject;

    public void operate(){
        // do something else
        subject.doSomething();
    }
}
```

## 使用

客户在使用的时候，也无需知道实际跟他打交道的是谁，这也是代理模式所要做到，就是对客户透明

```java
Subject subject = new Proxy();
subject.operate();
```

## 类图

![](https://images0.cnblogs.com/blog/533121/201411/261700405126302.png)

## 实例

想象系统有一个服务接口，它可以对用户进行CRUD

```java
interface UserService{
    void addUser();
}
```

这样的一个服务不仅可以存在本地，也能存在于远程的服务器上，我们可以通过代理模式，来实现像调用本地方法那样去调用服务器上的远程方法，这叫做RMI（远程方法调用），也是远程代理的一种

```java
class RemoteUserService implements UserService{

    @Override
    public void addUser() {
        // send add user message to remote server
    }
}
```

对于客户来说，就可以直接在本系统调用远端服务器上的方法，而且这个过程对客户是透明的

```java
UserService userService = new RemoteUserService();
userService.addUser();
```