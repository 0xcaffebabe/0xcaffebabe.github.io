---
layout: post
title:  "设计模式(十三):职责链模式"
date:   2019-12-23T010:00:00
category: 设计模式
tags: [设计模式]
---

使多个对象都有机会处理请求，避免发送者与接受者之间的耦合

# 职责链模式

有时候，一个请求可能不止被一个对象处理，而是被一串对象处理，也有可能不会有对象去处理这样的一个消息

## 处理器

处理器是组成处理链的单位，多个处理器组合成一条处理链

```java
interface Handler{
    void process(Request req,Response res);
}
```

看到这个接口，学习过JAVA WEB开发的一定会很眼熟，这和Filter的接口是很像的，一个请求从外向内被一次次处理，同时，一个结果也会从内到外一层层传递出来

## 职责链

一个典型的职责链可能是这样的

```java
class Handler1 implements Handler{
    private Handler nextHandler;

    @Override
    public void process(Request req, Response res) {
        // do something
        if (nextHandler != null){
            nextHandler.process(req,res);
        }
    }
}
```

- 结构图

![](https://s2.ax1x.com/2019/04/01/AsHpyq.png)

## 类图

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574654436690&di=48ae1c547c211016404e86d225d15050&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D519770121%2C2436189056%26fm%3D214%26gp%3D0.jpg)

## 何时使用

- 有多个对象可以处理请求，但谁能处理，是在运行期决定的
- 不明确请求接受者
- 处理请求的对象是动态指定的

## 效果

- 请求发送者与请求接受者耦合降低
- 拥有动态添加职责的灵活性
- **但是不保证被接受**

## 实例

- JAVA EE Servlet api中的Filter

这里 Filter对应的是Handler

```java
public interface Filter {
    //...

    void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException;
    //...
}
```

但稍微有点不同的是，Filter引入了一个FilterChain

```java
public interface FilterChain {
    void doFilter(ServletRequest var1, ServletResponse var2) throws IOException, ServletException;
}
```

主要原因是因为，FilterChain中的Filter是系统指定的，另外一个原因是通过调用FilterChain，可以在下一个Filter返回Response后继续做点什么

