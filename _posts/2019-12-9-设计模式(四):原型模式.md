---
layout: post
title:  "设计模式(四):原型模式"
date:   2019-12-9T012:00:00
category: 设计模式
tags: [设计模式]
---


通过一个原型对象创建新的对象

# 原型模式

在我们的系统当中，可能会需要一个类的很多很多子对象，但这些子对象的差别又都很小，那么我们就可以使用原型模式来生成这些子对象

## 原型接口

首先，我们定义这样的一个类，它是所有子对象的父接口,并且它由一个抽象方法，可以生成原型对象，但这个功能是由其子类实现

```java
abstract class Prototype{
    abstract Prototype create();
}
```

## 具体原型

接下来，我们还需要两个具体原型类，我们的所有子对象都是基于它们两个衍生出来的

```java
class ConcretePrototype1 extends Prototype{
    @Override
    Prototype create() {
        return this.clone();
    }
}

class ConcretePrototype2 extends Prototype{
    @Override
    Prototype create() {
        return this.clone();
    }
}
```

## 使用

使用时，我们创建出具体的原型对象，并克隆它出来，再做一些其他的事，就可以生成我们的专属对象

```java
Prototype prototype = new ConcretePrototype1().create();
prototype.doSomething(); // new object
```

## 效果

- 可以在运行时刻动态增加和删除产品
- 一个对象只要做一些操作，就会变成新对象
- 减少子类

## 问题

- 原型对象过多的时候，可以使用一个原型管理器来管理这些原型

## 类图

![](https://zhenyulu.cnblogs.com/images/cnblogs_com/zhenyulu/Pic55.gif)

## 实例

在电路设计中，有逻辑门的概念，我们可以创建一个抽象逻辑门类

```java
abstract class LogicGate{

    abstract LogicGate create();
    
}
```

并创建其具体类:与门与非门

```java
class AndLogicGate extends LogicGate{

    @Override
    LogicGate create() {
        return this.clone();
    }

}

class NotLogicGate extends LogicGate{

    @Override
    LogicGate create() {
        return this.clone();
    }

}
```

在使用时，只要根据原型创建新对象即可

```java
LogicGate logicGate = new AndLogicGate().create();
logicGate.doSomething(); // new logic gate
```

