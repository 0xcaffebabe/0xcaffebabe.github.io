---
layout: post
title:  "使用AOP来实现接口请求频率限制"
date:   2019-04-20T12:41:07
category: JAVA
tags: [JAVA]
---

使用AOP来实现接口请求频率限制

<p>老规矩，定义一个注解：</p><pre><code>/*<br>* 被该注解修饰的方法都会被切面拦截进行请求次数限制<br>*/<br>@Retention(RetentionPolicy.RUNTIME)<br>@Target(ElementType.METHOD)<br>public @interface Limit {<br>    int maxRequestPerMinute();<br>}</code></pre><p>我们在想要进行频率限制的方法上添加注解：</p><pre><code>@RequestMapping("/")<br>    @Limit(maxRequestPerMinute = 10)<br>    public String index(){<br>        return "index.html";<br>    }</code></pre><p>定义一个切面，代码如下（代码很长，可以跳到最后看分析）：</p><pre><code>/**<br> * @author my<br> */<br>@Aspect<br>@Component<br>@Order(1)<br>public class RequestLimitAspect {<br><br>    public static final String REQUEST_LIMIT = "requestLimit";<br>    public static final int MINTUE = 60000;<br><br>    @Pointcut("@annotation(wang.ismy.zbq.annotations.Limit)")<br>    public void pointCut() {<br>    }<br><br>    @Before("pointCut()")<br>    public void before(JoinPoint joinPoint) {<br>        var session = getCurrentUserSession();<br><br>        Signature signature = joinPoint.getSignature();<br>        MethodSignature methodSignature = (MethodSignature) signature;<br>        Method method = methodSignature.getMethod();<br>        var a = method.getAnnotation(Limit.class);<br><br>        if (session == null) {<br>            ErrorUtils.error(R.UNKNOWN_ERROR);<br>        }<br><br>        if (session.getAttribute(REQUEST_LIMIT) == null) {<br>            Map&lt;String, RequestLimitDTO&gt; map = new HashMap&lt;&gt;();<br>            session.setAttribute(REQUEST_LIMIT, map);<br>        }<br>        Map&lt;String, RequestLimitDTO&gt; map = (Map&lt;String, RequestLimitDTO&gt;) session.getAttribute(REQUEST_LIMIT);<br><br>        String methodName = joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName();<br><br>        if (map.get(methodName) == null) {<br>            RequestLimitDTO dto = new RequestLimitDTO();<br>            dto.setLastRequestTime(System.currentTimeMillis());<br>            dto.setRequestCount(0);<br>            map.put(methodName, dto);<br>        } else {<br>            RequestLimitDTO dto = map.get(methodName);<br>            // 如果当前请求距离上一次请求时间间隔大于60s，则清空计数器<br>            if (System.currentTimeMillis()-dto.getLastRequestTime() &gt;= MINTUE) {<br>                dto.setRequestCount(0);<br>            }<br><br>            dto.increaseCount();<br>            // 如果当前请求计数器的大于设定的阈值，则拒绝此次请求<br>            if (dto.getRequestCount() &gt; a.maxRequestPerMinute()) {<br>                ErrorUtils.error(R.REQUEST_FREQUENTLY);<br>            }<br><br>            dto.setLastRequestTime(System.currentTimeMillis());<br><br><br>        }<br><br><br>    }<br><br>    private HttpSession getCurrentUserSession() {<br>        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();<br>        return request.getSession();<br>    }<br>}</code></pre><p>那么，在这里谈谈这个频率限制的大概实现：</p><p>首先，被注解修饰的方法都会经过这个前置通知：</p><p>&nbsp; &nbsp; 1）获取该切面的方法全名。<br></p><p>&nbsp; &nbsp; 2）从session当中通过这个方法全名获取对应的请求dto（dto使用哈希表与方法全名进行映射）：</p><pre><code> * @author my<br> */<br>@Data<br>public class RequestLimitDTO {<br><br>    private Integer requestCount;<br><br>    private Long lastRequestTime;<br><br>    public synchronized void increaseCount(){<br>        requestCount++;<br>    }<br><br>    public synchronized void setRequestCount(Integer requestCount) {<br>        this.requestCount = requestCount;<br>    }<br>}</code></pre><p>&nbsp; &nbsp; 那么重点来了：<br></p><p>&nbsp; &nbsp; 算法的核心是这段：</p><pre><code>if (map.get(methodName) == null) {<br>    RequestLimitDTO dto = new RequestLimitDTO();<br>    dto.setLastRequestTime(System.currentTimeMillis());<br>    dto.setRequestCount(0);<br>    map.put(methodName, dto);<br>} else {<br>    RequestLimitDTO dto = map.get(methodName);<br>    // 如果当前请求距离上一次请求时间间隔大于60s，则清空计数器<br>    if (System.currentTimeMillis()-dto.getLastRequestTime() &gt;= MINTUE) {<br>        dto.setRequestCount(0);<br>    }<br><br>    dto.increaseCount();<br>    // 如果当前请求计数器的大于设定的阈值，则拒绝此次请求<br>    if (dto.getRequestCount() &gt; a.maxRequestPerMinute()) {<br>        ErrorUtils.error(R.REQUEST_FREQUENTLY);<br>    }<br><br>    dto.setLastRequestTime(System.currentTimeMillis());<br>}</code></pre><p>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码没有什么特别的地方，只是要注意的是increase和setRequestCount方法都要被synchronized关键字修饰，避免在并发的情况下出现数据不一致。<br></p><p>&nbsp;最后，不可否认，为了快速实现这个功能，这段代码写的很烂，很多地方实现得都不优美。<br></p><p>比如</p><pre><code>if (System.currentTimeMillis()-dto.getLastRequestTime() &gt;= MINTUE) {</code></pre><p>这里的MINUTE常量可以让客户端程序员自行指定 ，这样就能拥有更多的灵活性。</p>